const { ChatbotQuestion, ChatbotCategory } = require('../models');
const { Op } = require('sequelize');

/**
 * Servicio para manejar estad√≠sticas de usuario y m√©tricas ponderadas
 * Implementa la l√≥gica de contadores y c√°lculos de caracter√≠sticas usando MySQL
 * Dise√±ado para microservicios - no requiere verificaci√≥n de usuario
 */

class UserStatsService {
  constructor() {
    // Pesos de las categor√≠as seg√∫n la especificaci√≥n
    this.categoryWeights = {
      entrenamiento: 3,
      nutricion: 2,
      recuperacion: 2,
      prevencion: 2,
      equipamiento: 1
    };
  }

  /**
   * Obtiene las estad√≠sticas actuales de un usuario desde la base de datos
   * @param {number} userId - ID del usuario (referencia externa)
   * @returns {Object} - Estad√≠sticas del usuario
   */
  async getUserStats(userId) {
    try {
      console.log(`üìä Obteniendo estad√≠sticas para usuario ${userId}`);
      
      // Obtener conteo de preguntas por categor√≠a
      const questionStats = await ChatbotQuestion.findAll({
        where: { user_id: userId },
        include: [{
          model: ChatbotCategory,
          attributes: ['name']
        }],
        attributes: [
          [ChatbotQuestion.sequelize.fn('COUNT', ChatbotQuestion.sequelize.col('ChatbotQuestion.id')), 'count'],
          'category_id'
        ],
        group: ['category_id', 'ChatbotCategory.name']
      });

      // Inicializar contadores
      const stats = {
        preguntas_nutricion: 0,
        preguntas_entrenamiento: 0,
        preguntas_recuperacion: 0,
        preguntas_prevencion_lesiones: 0,
        preguntas_equipamiento: 0,
        ultima_actualizacion: new Date().toISOString()
      };

      // Mapear resultados de la BD a los nombres esperados
      const categoryMapping = {
        'Nutrici√≥n': 'preguntas_nutricion',
        'Entrenamiento': 'preguntas_entrenamiento', 
        'Recuperaci√≥n': 'preguntas_recuperacion',
        'Prevenci√≥n': 'preguntas_prevencion_lesiones',
        'Equipamiento': 'preguntas_equipamiento'
      };

      questionStats.forEach(stat => {
        const categoryName = stat.ChatbotCategory.name;
        const fieldName = categoryMapping[categoryName];
        if (fieldName) {
          stats[fieldName] = parseInt(stat.dataValues.count);
        }
      });

      // Calcular score ponderado
      const weightedScore = this.calculateWeightedScore(stats);
      stats.score_ponderado = weightedScore;

      console.log(`‚úÖ Estad√≠sticas obtenidas para usuario ${userId}:`, stats);
      return stats;

    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas:', error);
      throw new Error(`Error al obtener estad√≠sticas: ${error.message}`);
    }
  }

  /**
   * Actualiza las estad√≠sticas de un usuario despu√©s de una clasificaci√≥n
   * @param {number} userId - ID del usuario (referencia externa)
   * @param {string} category - Categor√≠a de la pregunta
   * @returns {Object} - Estad√≠sticas actualizadas
   */
  async updateUserStats(userId, category) {
    try {
      console.log(`üìä Actualizando estad√≠sticas para usuario ${userId}, categor√≠a: ${category}`);
      
      // Obtener el ID de la categor√≠a
      const categoryRecord = await ChatbotCategory.findOne({
        where: { name: category }
      });

      if (!categoryRecord) {
        throw new Error(`Categor√≠a no encontrada: ${category}`);
      }

      // Obtener estad√≠sticas actuales
      const stats = await this.getUserStats(userId);
      
      console.log(`‚úÖ Estad√≠sticas actualizadas para usuario ${userId}`);
      return stats;

    } catch (error) {
      console.error('‚ùå Error actualizando estad√≠sticas:', error);
      throw new Error(`Error al actualizar estad√≠sticas: ${error.message}`);
    }
  }

  /**
   * Guarda una pregunta clasificada en la base de datos
   * @param {number} userId - ID del usuario (referencia externa)
   * @param {string} question - Pregunta del usuario
   * @param {string} categoryName - Categor√≠a clasificada
   * @returns {Object} - Pregunta guardada
   */
  async saveQuestion(userId, question, categoryName) {
    try {
      console.log(`üíæ Guardando pregunta para usuario ${userId}, categor√≠a: ${categoryName}`);
      
      // Buscar la categor√≠a por nombre
      const category = await ChatbotCategory.findOne({
        where: { name: categoryName }
      });

      if (!category) {
        throw new Error(`Categor√≠a no encontrada: ${categoryName}`);
      }

      // Guardar la pregunta
      const savedQuestion = await ChatbotQuestion.create({
        user_id: userId,
        question: question,
        category_id: category.id,
        created_at: new Date()
      });

      console.log(`‚úÖ Pregunta guardada con ID: ${savedQuestion.id}`);
      return savedQuestion;

    } catch (error) {
      console.error('‚ùå Error guardando pregunta:', error);
      throw new Error(`Error al guardar pregunta: ${error.message}`);
    }
  }

  /**
   * Calcula el score ponderado basado en las estad√≠sticas del usuario
   * @param {Object} stats - Estad√≠sticas del usuario
   * @returns {number} - Score ponderado
   */
  calculateWeightedScore(stats) {
    let totalScore = 0;
    
    // Calcular score para cada categor√≠a
    totalScore += stats.preguntas_entrenamiento * this.categoryWeights.entrenamiento;
    totalScore += stats.preguntas_nutricion * this.categoryWeights.nutricion;
    totalScore += stats.preguntas_recuperacion * this.categoryWeights.recuperacion;
    totalScore += stats.preguntas_prevencion_lesiones * this.categoryWeights.prevencion;
    totalScore += stats.preguntas_equipamiento * this.categoryWeights.equipamiento;
    
    return Math.round(totalScore * 100) / 100;
  }

  /**
   * Obtiene las preferencias del usuario basadas en sus preguntas
   * @param {number} userId - ID del usuario (referencia externa)
   * @returns {Object} - Preferencias del usuario
   */
  async getUserPreferences(userId) {
    try {
      const stats = await this.getUserStats(userId);
      
      // Encontrar la categor√≠a con m√°s preguntas
      const categories = [
        { name: 'entrenamiento', count: stats.preguntas_entrenamiento },
        { name: 'nutricion', count: stats.preguntas_nutricion },
        { name: 'recuperacion', count: stats.preguntas_recuperacion },
        { name: 'prevencion', count: stats.preguntas_prevencion_lesiones },
        { name: 'equipamiento', count: stats.preguntas_equipamiento }
      ];

      const maxCategory = categories.reduce((max, current) => 
        current.count > max.count ? current : max
      );

      return {
        primaryInterest: maxCategory.name,
        totalQuestions: Object.values(stats).filter(val => typeof val === 'number' && val > 0).reduce((a, b) => a + b, 0),
        categoryDistribution: categories,
        weightedScore: stats.score_ponderado
      };

    } catch (error) {
      console.error('‚ùå Error obteniendo preferencias:', error);
      throw new Error(`Error al obtener preferencias: ${error.message}`);
    }
  }

  /**
   * Obtiene estad√≠sticas agregadas de todos los usuarios
   * @returns {Object} - Estad√≠sticas globales
   */
  async getGlobalStats() {
    try {
      const globalStats = {
        totalUsers: 0,
        totalQuestions: 0,
        categoryDistribution: {
          entrenamiento: 0,
          nutricion: 0,
          recuperacion: 0,
          prevencion: 0,
          equipamiento: 0
        },
        averageWeightedScore: 0
      };

      // Obtener estad√≠sticas globales desde la base de datos
      const questionStats = await ChatbotQuestion.findAll({
        include: [{
          model: ChatbotCategory,
          attributes: ['name']
        }],
        attributes: [
          [ChatbotQuestion.sequelize.fn('COUNT', ChatbotQuestion.sequelize.col('ChatbotQuestion.id')), 'count'],
          'category_id'
        ],
        group: ['category_id', 'ChatbotCategory.name']
      });

      // Contar usuarios √∫nicos
      const uniqueUsers = await ChatbotQuestion.count({
        distinct: true,
        col: 'user_id'
      });

      globalStats.totalUsers = uniqueUsers;

      // Mapear resultados
      const categoryMapping = {
        'Nutrici√≥n': 'nutricion',
        'Entrenamiento': 'entrenamiento',
        'Recuperaci√≥n': 'recuperacion',
        'Prevenci√≥n': 'prevencion',
        'Equipamiento': 'equipamiento'
      };

      questionStats.forEach(stat => {
        const categoryName = stat.ChatbotCategory.name;
        const fieldName = categoryMapping[categoryName];
        if (fieldName) {
          const count = parseInt(stat.dataValues.count);
          globalStats.categoryDistribution[fieldName] = count;
          globalStats.totalQuestions += count;
        }
      });

      return globalStats;

    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas globales:', error);
      throw new Error(`Error al obtener estad√≠sticas globales: ${error.message}`);
    }
  }

  /**
   * Obtiene estad√≠sticas semanales de un usuario
   * @param {number} userId - ID del usuario (referencia externa)
   * @param {number} days - N√∫mero de d√≠as hacia atr√°s (por defecto 7)
   * @returns {Object} - Estad√≠sticas del per√≠odo especificado
   */
  async getUserWeeklyStats(userId, days = 7) {
    try {
      console.log(`üìä Obteniendo estad√≠sticas para usuario ${userId}, √∫ltimos ${days} d√≠as`);
      
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      // Obtener estad√≠sticas del per√≠odo especificado
      const stats = await this.getStatsForPeriod(userId, startDate, endDate);
      
      const weeklyStats = {
        period: {
          startDate: startDate.toISOString().split('T')[0],
          endDate: endDate.toISOString().split('T')[0],
          days: days
        },
        stats: stats
      };
      
      console.log(`‚úÖ Estad√≠sticas obtenidas para usuario ${userId}`);
      return weeklyStats;
      
    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas:', error);
      throw new Error(`Error al obtener estad√≠sticas: ${error.message}`);
    }
  }

  /**
   * Obtiene estad√≠sticas para un per√≠odo espec√≠fico
   * @param {number} userId - ID del usuario
   * @param {Date} startDate - Fecha de inicio
   * @param {Date} endDate - Fecha de fin
   * @returns {Object} - Estad√≠sticas del per√≠odo
   */
  async getStatsForPeriod(userId, startDate, endDate) {
    try {
      const questionStats = await ChatbotQuestion.findAll({
        where: {
          user_id: userId,
          created_at: {
            [Op.between]: [startDate, endDate]
          }
        },
        include: [{
          model: ChatbotCategory,
          attributes: ['name']
        }],
        attributes: [
          [ChatbotQuestion.sequelize.fn('COUNT', ChatbotQuestion.sequelize.col('ChatbotQuestion.id')), 'count'],
          'category_id'
        ],
        group: ['category_id', 'ChatbotCategory.name']
      });

      // Inicializar contadores
      const stats = {
        preguntas_nutricion: 0,
        preguntas_entrenamiento: 0,
        preguntas_recuperacion: 0,
        preguntas_prevencion_lesiones: 0,
        preguntas_equipamiento: 0,
        total_preguntas: 0
      };

      // Mapear resultados de la BD a los nombres esperados
      const categoryMapping = {
        'Nutrici√≥n': 'preguntas_nutricion',
        'Entrenamiento': 'preguntas_entrenamiento',
        'Recuperaci√≥n': 'preguntas_recuperacion',
        'Prevenci√≥n': 'preguntas_prevencion_lesiones',
        'Equipamiento': 'preguntas_equipamiento'
      };

      questionStats.forEach(stat => {
        const categoryName = stat.ChatbotCategory.name;
        const fieldName = categoryMapping[categoryName];
        if (fieldName) {
          const count = parseInt(stat.dataValues.count);
          stats[fieldName] = count;
          stats.total_preguntas += count;
        }
      });

      // Calcular score ponderado
      stats.score_ponderado = this.calculateWeightedScore(stats);
      
      return stats;
      
    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas del per√≠odo:', error);
      throw error;
    }
  }
}

// Instancia singleton del servicio
const userStatsService = new UserStatsService();

/**
 * Inicializa las categor√≠as del chatbot en la base de datos
 */
async function initializeCategories() {
  try {
    console.log('üìã Inicializando categor√≠as del chatbot...');
    
    const categories = [
      { name: 'Nutrici√≥n' },
      { name: 'Entrenamiento' },
      { name: 'Recuperaci√≥n' },
      { name: 'Prevenci√≥n' },
      { name: 'Equipamiento' }
    ];

    for (const category of categories) {
      await ChatbotCategory.findOrCreate({
        where: { name: category.name },
        defaults: category
      });
    }

    console.log('‚úÖ Categor√≠as inicializadas correctamente');
    return true;
  } catch (error) {
    console.error('‚ùå Error inicializando categor√≠as:', error);
    throw error;
  }
}

// Exportar funciones
module.exports = {
  updateUserStats: (userId, category) => userStatsService.updateUserStats(userId, category),
  getUserStats: (userId) => userStatsService.getUserStats(userId),
  getUserPreferences: (userId) => userStatsService.getUserPreferences(userId),
  getGlobalStats: () => userStatsService.getGlobalStats(),
  saveQuestion: (userId, question, category) => userStatsService.saveQuestion(userId, question, category),
  calculateWeightedScore: (stats) => userStatsService.calculateWeightedScore(stats),
  initializeCategories,
  getUserWeeklyStats: (userId, days) => userStatsService.getUserWeeklyStats(userId, days)
}; 